
[back](../../20251216定期月總結.md)

## 協程

> event-loop / Coroutine
> 處理IO-密集任務的方法邏輯
> 要有可以暫停、交出控制權、稍後再繼續執行的函數

### python

> 有官方標準寫法
> 需要額外轉寫非同步邏輯

```python
# asyncio、trio、gevent
import asyncio

async def task(name):
    print(f"{name} start")
    await asyncio.sleep(1)  # 這裡暫停，去做其他協程
    print(f"{name} done")

async def main():
    await asyncio.gather(task("A"), task("B"), task("C"))

asyncio.run(main())
```

### java

> java沒有標準語法(函式庫)實作協程
> 有類似但稍微底層的類協程寫法
> 有協程相關的第三方函式庫

#### 一般的線程

> 同步邏輯

如果使用sleep，會阻塞該thread，該thread雖然閒置，但是CPU會去執行其他thread的任務

阻塞=>卡住整個 worker=>不能執行 thread pool 中的其他任務

#### ForkJoinPool

> 同步邏輯

如果使用sleep，會短暫阻塞該thread，隨後會steal job去做其他事情
底層是 wait/notify/sleep/join/start/interrupt

#### Java NIO / Selector

> 非同步邏輯
> java 標準函式庫
> 必須手動寫loop分配
> 屬於稍微底層的類協程寫法

#### Reactor

> 非同步邏輯
> 第三方函式庫的協程寫法
> 多數現代框架的底層
> 屬於進階技能，可以先去學基本的

- Netty：非阻塞 IO + 事件驅動 → 類協程底層
- Reactor / RxJava / Spring WebFlux：封裝回調 → 類協程行為，提供鏈式 API

#### Virtual Thread

> 同步邏輯
> jvm底層實作類似協程功能
> 類似go的Virtual Thread

```
try (
	var executor = Executors.newVirtualThreadPerTaskExecutor()
) {
    executor.submit(() -> {
        var res = client.send(request); // 這裡可以阻塞
        return res.body();
    });
}
```

