
[back](../../20251216定期月總結.md)

## 需求與特色

1️⃣ 需求核心

1. **定時觸發（排程）**
    - 任務需要在指定時間、週期或條件下執行
    - 支援多種排程頻率：每天、每小時、每分鐘，甚至高頻短任務
        
2. **多組織 / 多租戶**
    - 每個組織可能有不同的推播邏輯
    - 任務彼此相互獨立，但可能需要統一管理或統計
        
3. **推播任務（Worker）**
    
    - 真正執行推送操作：發送通知、訊息或執行業務邏輯
    - 任務執行可能涉及 I/O（網路請求）、計算（資料生成、加密）、狀態更新
        
4. **狀態回報與監控**
    
    - Scheduler 或管理中心需要收集任務執行狀態：成功/失敗、耗時、錯誤訊息
    - 方便監控、重試、補償

2️⃣ 任務特色

|特色|說明|
|---|---|
|**頻率**|任務可能高頻（每分鐘）或低頻（每日/每週），頻率決定 Worker 選型|
|**執行時間**|任務執行時間可能短（幾秒）或長（幾分鐘），影響資源占用策略|
|**資源需求**|部分任務 CPU / 記憶體密集（資料處理、加密），部分 I/O 為主（API 推播）|
|**依賴性**|部分任務獨立，部分任務有序列依賴或共享狀態|
|**容錯需求**|單個任務失敗不應影響其他組織任務，需支援重試或補償|
|**開發迭代頻率**|組織邏輯可能頻繁變動，需要快速迭代的能力|

---

## 解決方案

1️⃣ 單一程式集中排程 + 推播（Java 全部集中式）

適用場景
- **組織數量少**（例如 <10）
- **推播邏輯統一、變動少**
- **任務週期長、頻率低**
- **企業內部資源充足**，不介意 JVM 常駐消耗

特點
- 部署簡單：只需部署一個應用
- 監控方便：統一收集統計資料
- 缺點：單個組織問題可能影響整體，擴展性差

實務案例
- 內部報表推送系統，每天生成一次報表
- 少量組織、規則固定的通知系統

---

2️⃣ 多 Worker 常駐（Python Worker + Supervisor）

> 在多 Worker 常駐模式下，**單個 Python Worker 進程較輕量，但總體記憶體占用隨 Worker 數量增加而線性上升**，相比單一 JVM 不一定節省記憶體，但容錯性與管理彈性更高。

適用場景

- **組織數量中等到多**（10~50）
- **每個組織邏輯不同**
- **需要快速迭代和部署**
- **資源中等**，可承受多個進程長時間常駐

特點

- 每個組織 Worker crash 只影響自己 → 容錯性好
- Supervisor 可統一管理 Worker
- 缺點：長時間占用多個進程，監控和統計需要額外整合

實務案例

- SaaS 推播平台，客戶邏輯多樣
- 多組織通知系統，每個組織排程頻率不同


3️⃣ 排程與推播分離（Scheduler + Worker），Worker 可 Python / Native Image

> GraalVM可執行python、java、java Native Image等多種程式

適用場景

- **組織數量多**（10~數百）
- **短頻、CPU 密集或高頻任務**
- **資源有限**，需要短暫啟動 Worker 並回收
- **需要統一監控、容錯高**
- **希望混合語言部署**，Python 或 Native Image 可共存
    

### 特點

- Scheduler 統一管理、收集回報 → 監控集中
- Worker 短暫啟動 → 資源利用率高
- 容錯性高：單任務 crash 不影響整體
- 缺點：Scheduler 必須可靠；Native Image Worker 修改需重新編譯
    

### 實務案例

- 高頻推播系統，每分鐘觸發多個組織任務
- IoT 任務推送，需要短暫啟動、資源回收
- 混合 CPU 密集與邏輯迭代需求的系統


